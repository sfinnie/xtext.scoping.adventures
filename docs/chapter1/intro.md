#Xtext Scoping Explained

TODO: intro...

##Sample language (version 1)
The first incarnation of our language is minimally simple.  It supports *Variable Declarations*:

    var foo

And *assignments*:

	foo = bar

That's it.  Completely useless as a language, but just enough to start looking at Scoping.  Here's the grammar:

	grammar xtext.scoping.Explained2 with org.eclipse.xtext.common.Terminals
	generate explained2 "http://www.scoping.xtext/Explained2"

	Program:
		statements+=Statement*;

	Statement:
		Variable | Assignment
	;

	Variable:
		'var' name=ID
	;

	Assignment:
		lhs=[Variable] '=' rhs=[Variable]
    ;

If we generate the xtext artefacts and run the project in a runtime instance, the following example will show no errors:

	var foo
	var bar
	var baz

	foo = bar
	bar = baz

Whereas this will fail:

	var foo

	foo = bar

because `bar` hasn't been declared.  This shows that scoping is already implemented in the language; it's provided as part of Xtext's 'sensible defaults'.  Which is very handy.  To understand how scoping works however, it's instructive to go back to first principles.  So we're going to disable the default support.

##Back to Basics
Xtext generates a scope provider for every language which inherits default behaviour from the Xtext framework.  In our case, the generated Scope Provider is  `Xscope1ScopeProvider.xtend`.    Here's how it looks as generated by Xtext:

	xtext.scoping.adventures.scoping

	class Xscope1ScopeProvider extends
        org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider {

	}

The 'sensible default' behaviour is provided by `AbstractDeclarativeScopeProvider`.  If we track up the type hierarchy, we end up at the Interface `org.eclipse.xtext.scoping.IScopeProvider`.  Here it is, minus comments:

    package org.eclipse.xtext.scoping;
    import org.eclipse.emf.ecore.EObject;
    import org.eclipse.emf.ecore.EReference;

    public interface IScopeProvider {

    	IScope getScope(EObject context, EReference reference);

    }

So a `ScopeProvider` implements a single method `getScope()` which:
 * Takes an `EObject` and `EReference` as parameters, and
 * returns an `IScope`

We'll come back to those in a minute.  For now, let's disable the default behaviour by having our Scope Provider implement `IScopeProvider` directly instead of inheriting from `AbstractDeclarativeScopeProvider`.  Here's the revised implementation:

	package xtext.scoping.scoping

	import org.eclipse.xtext.scoping.IScope
	import org.eclipse.emf.ecore.EObject
	import org.eclipse.emf.ecore.EReference

	class Explained2ScopeProvider implements org.eclipse.xtext.scoping.IScopeProvider {

		override getScope(EObject context, EReference reference) {
			return IScope.NULLSCOPE
		}

	}

`IScope.NULLSCOPE` is the scoping equivalent of `null`.  In other words, it says there's nothing in scope.  If we run the updated project in a runtime eclipse instance, the previously working example should now fail; and indeed it does.  Each variable reference in each assignment results in an error, e.g.

    Couldn't resolve reference to Variable 'foo'.

OK, that's what we expected.  It's a bit tedious to check every example in a runtime instance though, so let's use a unit test instead.  Here's the test:

package xtext.scoping.adventures.xscope1.tests

    import com.google.inject.Inject
    import org.eclipse.xtext.junit4.InjectWith
    import org.eclipse.xtext.junit4.XtextRunner
    import org.eclipse.xtext.junit4.util.ParseHelper
    import org.eclipse.xtext.junit4.validation.ValidationTestHelper
    import org.eclipse.xtext.scoping.IScopeProvider
    import org.junit.Test
    import org.junit.runner.RunWith
    import xtext.scoping.adventures.xscope1.Program
    import xtext.scoping.adventures.Xscope1InjectorProvider

    @InjectWith(Xscope1InjectorProvider)
    @RunWith(XtextRunner)
    class TestScopeProvider {
    	@Inject extension ParseHelper<Program>
    	@Inject extension ValidationTestHelper
    	@Inject extension IScopeProvider

    	@Test
    	def void testSimpleCrossReferencesWork() {
    		val program='''
    			var foo
    			var bar

    			foo = bar
    		'''.parse
    		program.assertNoErrors
    	}

    }
There's a fair bit of supporting infrastructure in there, but the meat is in the `testSimpleCrossReferencesWork` method.  `program.assertNoErrors` will succeed if the model parses successfully - which means references are correctly resolved.  Given our null scope provider, we'd expect that to fail. And sure enough that's what happens:

    java.lang.AssertionError: Expected no errors, but got :
    ERROR (org.eclipse.xtext.diagnostics.Diagnostic.Linking) 'Couldn't resolve reference to Variable 'foo'.' on Assignment
    ERROR (org.eclipse.xtext.diagnostics.Diagnostic.Linking) 'Couldn't resolve reference to Variable 'bar'.' on Assignment

##Getting to Green
So in true [TDD](http://en.wikipedia.org/wiki/Test-driven_development) style, we now have a broken test.  Continuing in that theme, we should ask: "what's the simplest thing we can do to get to green?"

Intuitively, what we want is obvious:

* The `foo` reference in the assignment resolved to the `foo` declaration; and
* The `bar` reference resolved to the `bar` declaration.

To do that requires our `getScope` method to return a non-null `IScope`;more specifically, that `IScope` needs to include the two Variable declarations.

###What's in an `IScope`?
In simple terms, it's a map (or a dictionary).  It contains a set of (key, value) pairs where the 'key' is the text used to perform a match with the reference text, and the 'value' is the object represented by the text.  So informally, our scope needs to look like this:

    {
      'foo', Variable(foo),
      'bar', Variable(bar)
    }

where `Variable(x)` means the object representing the Variable declaration with name `x`.

Here's the relevant part of the IScope definition:

    public interface IScope {

    	/**
    	 * Find the first description that matches the given name.
    	 *
    	 * @param name the name of the to-be-found element.
    	 * @return the first element that matches the {@link QualifiedName name}.
    	 */
    	IEObjectDescription getSingleElement(QualifiedName name);

      //..remainder elided
    }

Whilst it doesn't tell us how to *create* an IScope, it does at least show how the resultant instance is used.  Callers provide a `name` which is used for matching purposes.  If a match is found, then an `IEObjectDescription` is returned to represent the relevant object.

Relating this back to the informal description above:

  * each 'name' needs to be specifically an instance of `QualifiedName`; and
  * each 'Variable(x)' needs to be an `IEObjectDescription`.

We'll look into `QualifiedName` in more detail later.  For now, it's sufficient to know that it's a datatype for segmented names such as `org.example.package.Class`.

`IEObjectDescription` is a summarised description of a model element.  Xtext uses the [Eclipse Modeling Framework](https://www.eclipse.org/modeling/emf/) (EMF) internally.  Again we'll look at that in more detail below, but for now it's enough to know that:

 * Every construct in our language results in the creation of an EMF class, specifically a subtype of the EMF base class `EObject`.  
 * `IEObjectDescription` is a lightweight description of an EObject that improves scalability for larger and/or multi-file models.

Here's the `IEObjectDescription` Interface:

    public interface IEObjectDescription {

    	/**
    	 * @return the name, this element can be accessed by.
    	 */
    	QualifiedName getName();

    	/**
    	 * @return the qualified name of the element.
    	 */
    	QualifiedName getQualifiedName();

    	/**
    	 * @return the actual element or a proxy.
    	 */
    	EObject getEObjectOrProxy();

    	/**
    	 * @return the full URI to the described element
    	 */
    	URI getEObjectURI();

    	/**
    	 * @return the EClass of the described element.
    	 */
    	EClass getEClass();
    }

Whilst reasonably intuitive, there's quite a lot in there.  Constructing an `IEObjectDescription` manually for each possible target feels like quite a lot of work.  Luckily Xtext provides some utility classes and methods to help.

##Building an `IScope`
One of those utility classes is [`org.eclipse.xtext.scoping.Scopes`](http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.7/org/eclipse/xtext/scoping/Scopes.html) which provides a collection of methods named `scopeFor()`.  Here's the simplest variant:

  	public static IScope scopeFor(Iterable<? extends EObject> elements)

So we provide a collection of the candidate targets and get back a ready-made scope containing them.  That sounds ideal; but how do we compute the candidate targets?

1. In our sample model, we have two targets: `foo` and `bar`
2. They are both instances of `Variable`

Xtext generates the `Variable` class from the language definition. In fact it generates an Interface and implementing Class.  As noted above, all generated model classes extend `EObject`.  So we just need to collect all the instances of `Variable` and supply that to `scopeFor`.  Here's how that looks:

    class Explained2ScopeProvider implements org.eclipse.xtext.scoping.IScopeProvider {

    	override getScope(EObject context, EReference reference) {
    		val Program root = EcoreUtil.getRootContainer(context) as Program
    		val vars=root.statements.filter(typeof(Variable))

        val scope=Scopes::scopeFor(vars)
        return scope
    	}

    }

It uses the EMF utility [`EcoreUtil.getRootContainer()`](http://download.eclipse.org/modeling/emf/emf/javadoc/2.5.0/org/eclipse/emf/ecore/util/EcoreUtil.html) to get the root of the model created by Xtext during parsing.  The method signature for `getRootContainer()` returns an `EObject`, but we know the root in our model is a `Program` from the grammar; so we cast it as such.  With the root object available, it's an easy task to select just the `Variable` instances from the collection of `Statements` contained in the program (remember `Variable` is a subtype of `Statement`).  Having computed the list of `Variables` we hand them over to `scopeFor()` to generate the Scope.

##Testing, Testing
Does it work?  Yes.  Running the Unit Test again 'gets to green'. Task accomplished!
